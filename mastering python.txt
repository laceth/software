>>> class ElectricCar(Car):
	def __init__(self, make, model, year):
		super().__init__(make, model, year)
		self.battery_size = 70
	def describe_battery(self):
		print("This car has a " + str(self.battery_size) + "-kWh battery.")
	def fill_gas_tank():
		
		print("This car doesn't need a gas tank!")

		
>>> my_tesla = ElectricCar('tesla', 'model s', 2016)
>>> print(my_tesla.get_descriptive_name())
2016 Tesla Model S
>>> my_tesla.describe_battery()
This car has a 70-kWh battery.
>>> my_tesla.fill_gas_tank
<bound method ElectricCar.fill_gas_tank of <__main__.ElectricCar object at 0x00000000034D37B8>>
>>> my_tesla.fill_gas_tank()
Traceback (most recent call last):
  File "<pyshell#296>", line 1, in <module>
    my_tesla.fill_gas_tank()
TypeError: fill_gas_tank() takes 0 positional arguments but 1 was given
>>> my_tesla.fill_gas_tank
<bound method ElectricCar.fill_gas_tank of <__main__.ElectricCar object at 0x00000000034D37B8>>
>>> 

error gert when indention not correct for def fill_gas_tank method


help(socket.gethostname)
to see the online help information from within the command
line.


1 def greet_user():
2 """Display a simple greeting."""
3 print("Hello!")
4 greet_user()

The text at 2 is a comment called a docstring, which describes
what the function does.

def greet_user(username):
"""Display a simple greeting."""
print("Hello, " + username.title() + "!")
greet_user('jesse')

Entering greet_user('jesse') calls greet_user() and gives the function the
information it needs to execute the print statement. The function accepts
the name you passed it and displays the greeting for that name:
Hello, Jesse!



Default Values
When writing a function, you can define a default value for each parameter.
If an argument for a parameter is provided in the function call, Python uses
the argument value. If not, it uses the parameter’s default value. So when
you define a default value for a parameter, you can exclude the corresponding
argument you’d usually write in the function call. Using default values
can simplify your function calls and clarify the ways in which your functions
are typically used.
For example, if you notice that most of the calls to describe_pet() are
being used to describe dogs, you can set the default value of animal_type to
'dog'. Now anyone calling describe_pet() for a dog can omit that information:
def describe_pet(pet_name, animal_type='dog'):
"""Display information about a pet."""
print("\nI have a " + animal_type + ".")
print("My " + animal_type + "'s name is " + pet_name.title() + ".")
describe_pet(pet_name='willie')



Returning a Simple Value
Let’s look at a function that takes a first and last name, and returns a neatly
formatted full name:
formatted_name.py  
1 def get_formatted_name(first_name, last_name):
"""Return a full name, neatly formatted."""
2 full_name = first_name + ' ' + last_name
3 return full_name.title()
4 musician = get_formatted_name('jimi', 'hendrix')
print(musician)
The definition of get_formatted_name() takes as parameters a first and last
name 1. The function combines these two names, adds a space between
them, and stores the result in full_name 2. The value of full_name is converted
to title case, and then returned to the calling line at 3.
When you call a function that returns a value, you need to provide a
variable where the return value can be stored. In this case, the returned
value is stored in the variable musician at 4. The output shows a neatly formatted
name made up of the parts of a person’s name:

Passing an Arbitrary Number of Arguments
Sometimes you won’t know ahead of time how many arguments a function
needs to accept. Fortunately, Python allows a function to collect an arbitrary
number of arguments from the calling statement.
For example, consider a function that builds a pizza. It needs to accept a
number of toppings, but you can’t know ahead of time how many toppings
a person will want. The function in the following example has one parameter,
*toppings, but this parameter collects as many arguments as the calling
line provides:
pizza.py def make_pizza(*toppings):
"""Print the list of toppings that have been requested."""
print(toppings)
make_pizza('pepperoni')
make_pizza('mushrooms', 'green peppers', 'extra cheese')
The asterisk in the parameter name *toppings tells Python to make an
empty tuple called toppings and pack whatever values it receives into this
tuple. The print statement in the function body produces output showing
that Python can handle a function call with one value and a call with three
values. It treats the different calls similarly. Note that Python packs the
arguments into a tuple, even if the function receives only one value:
('pepperoni',)
('mushrooms', 'green peppers', 'extra cheese')

Importing an Entire Module
To start importing functions, we first need to create a module. A module
is a file ending in .py that contains the code you want to import into your
www.it-ebooks.info
Functions 155
program. Let’s make a module that contains the function make_pizza(). To
make this module, we’ll remove everything from the file pizza.py except the
function make_pizza():
pizza.py def make_pizza(size, *toppings):
"""Summarize the pizza we are about to make."""
print("\nMaking a " + str(size) +
"-inch pizza with the following toppings:")
for topping in toppings:
print("- " + topping)
Now we’ll make a separate file called making_pizzas.py in the same
directory as pizza.py. This file imports the module we just created and then
makes two calls to make_pizza():
making_ import pizza
pizzas.py
u pizza.make_pizza(16, 'pepperoni')
pizza.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
When Python reads this file, the line import pizza tells Python to
open the file pizza.py and copy all the functions from it into this program.
You don’t actually see code being copied between files because Python
copies the code behind the scenes as the program runs. All you need
to know is that any function defined in pizza.py will now be available in
making_pizzas.py.
To call a function from an imported module, enter the name of
the module you imported, pizza, followed by the name of the function,
make_pizza(), separated by a dot u. This code produces the same output
as the original program that didn’t import a module:
Making a 16-inch pizza with the following toppings:
- pepperoni
Making a 12-inch pizza with the following toppings:
- mushrooms
- green peppers
- extra cheese
This first approach to importing, in which you simply write import followed
by the name of the module, makes every function from the module
available in your program. If you use this kind of import statement to import
an entire module named module_name.py, each function in the module is
available through the following syntax:
module_name.function_name()




####################################################################

Importing Specific Functions
You can also import a specific function from a module. Here’s the general
syntax for this approach:
from module_name import function_name
You can import as many functions as you want from a module by separating
each function’s name with a comma:
from module_name import function_0, function_1, function_2
The making_pizzas.py example would look like this if we want to import
just the function we’re going to use:
from pizza import make_pizza
make_pizza(16, 'pepperoni')
make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
With this syntax, you don’t need to use the dot notation when you call a
function. Because we’ve explicitly imported the function make_pizza() in the
import statement, we can call it by name when we use the function.
Using as to Give a Function an Alias

If the name of a function you’re importing might conflict with an existing
name in your program or if the function name is long, you can use a
short, unique alias—an alternate name similar to a nickname for the function.
You’ll give the function this special nickname when you import the
function.
Here we give the function make_pizza() an alias, mp(), by importing
make_pizza as mp. The as keyword renames a function using the alias you
provide:
from pizza import make_pizza as mp
mp(16, 'pepperoni')
mp(12, 'mushrooms', 'green peppers', 'extra cheese')
The import statement shown here renames the function make_pizza() to
mp() in this program. Any time we want to call make_pizza() we can simply
write mp() instead, and Python will run the code in make_pizza() while avoiding
any confusion with another make_pizza() function you might have written
in this program file.
The general syntax for providing an alias is:
from module_name import function_name as fn
\\



Styling Functions
You need to keep a few details in mind when you’re styling functions.
Functions should have descriptive names, and these names should use
lowercase letters and underscores. Descriptive names help you and others
understand what your code is trying to do. Module names should use these
conventions as well.
Every function should have a comment that explains concisely what
the function does. This comment should appear immediately after the
function definition and use the docstring format. In a well-documented
function, other programmers can use the function by reading only the
description in the docstring. They should be able to trust that the code
works as described, and as long as they know the name of the function,
the arguments it needs, and the kind of value it returns, they should be
able to use it in their programs.
If you specify a default value for a parameter, no spaces should be used
on either side of the equal sign:
def function_name(parameter_0, parameter_1='default value')
The same convention should be used for keyword arguments in function
calls:
function_name(value_0, parameter_1='value')
PEP 8 (https://www.python.org/dev/peps/pep-0008/ ) recommends that
you limit lines of code to 79 characters so every line is visible in a reasonably
sized editor window. If a set of parameters causes a function’s definition to
be longer than 79 characters, press enter after the opening parenthesis on
the definition line. On the next line, press tab twice to separate the list of
arguments from the body of the function, which will only be indented one
level.
Most editors automatically line up any additional lines of parameters to
match the indentation you have established on the first line:
def function_name(
parameter_0, parameter_1, parameter_2,
parameter_3, parameter_4, parameter_5):
function body...
If your program or module has more than one function, you can separate
each by two blank lines to make it easier to see where one function
ends and the next one begins.
All import statements should be written at the beginning of a file.
The only exception is if you use comments at the beginning of your file to
describe the overall program.


Styling Classes
A few styling issues related to classes are worth clarifying, especially as your
programs become more complicated.
Class names should be written in CamelCaps. To do this, capitalize the
first letter of each word in the name, and don’t use underscores. Instance
and module names should be written in lowercase with underscores between
words.
Every class should have a docstring immediately following the class definition.
The docstring should be a brief description of what the class does,
and you should follow the same formatting conventions you used for writing
docstrings in functions. Each module should also have a docstring describing
what the classes in a module can be used for.
You can use blank lines to organize code, but don’t use them excessively.
Within a class you can use one blank line between methods, and
within a module you can use two blank lines to separate classes.
If you need to import a module from the standard library and a module
that you wrote, place the import statement for the standard library module
www.it-ebooks.info
Classes 187
first. Then add a blank line and the import statement for the module you
wrote. In programs with multiple import statements, this convention makes
it easier to see where the different modules used in the program come from.


